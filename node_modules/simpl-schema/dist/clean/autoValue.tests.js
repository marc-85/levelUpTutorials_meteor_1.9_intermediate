"use strict";

var _expect = _interopRequireDefault(require("expect"));

var _SimpleSchema = require("../SimpleSchema");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable func-names, prefer-arrow-callback */
describe('autoValue', function () {
  describe('has correct information in function context', function () {
    it('empty', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.key).toBe('bar');
            (0, _expect.default)(this.closestSubschemaFieldName).toBe(null);
            (0, _expect.default)(this.isSet).toBe(false);
            (0, _expect.default)(this.value).toBe(undefined);
            (0, _expect.default)(this.operator).toBe(null);
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
          }

        }
      });
      schema.clean({});
    });
    it('normal other key', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.isSet).toBe(false);
            (0, _expect.default)(this.value).toBe(undefined);
            (0, _expect.default)(this.operator).toBe(null);
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: true,
              operator: null,
              value: 'clown'
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: true,
              operator: null,
              value: 'clown'
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
          }

        }
      });
      schema.clean({
        foo: 'clown'
      });
    });
    it('normal self and other key', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.isSet).toBe(true);
            (0, _expect.default)(this.value).toBe(true);
            (0, _expect.default)(this.operator).toBe(null);
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: true,
              operator: null,
              value: 'clown'
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: true,
              operator: null,
              value: 'clown'
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
          }

        }
      });
      schema.clean({
        foo: 'clown',
        bar: true
      });
    });
    it('parentField', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: Object,
          optional: true
        },
        'foo.bar': {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.parentField()).toEqual({
              isSet: true,
              operator: null,
              value: {}
            });
          }

        }
      });
      schema.clean({
        foo: {}
      });
    });
    it('closestSubschemaFieldName set', function () {
      const schema1 = new _SimpleSchema.SimpleSchema({
        dug: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.key).toBe('dig.dug');
            (0, _expect.default)(this.closestSubschemaFieldName).toBe('dig');
          }

        }
      });
      const schema2 = new _SimpleSchema.SimpleSchema({
        dig: {
          type: schema1,
          optional: true
        }
      });
      schema2.clean({
        dig: {}
      });
    });
    it('normal self and no other key with unset', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.isSet).toBe(true);
            (0, _expect.default)(this.value).toBe(false);
            (0, _expect.default)(this.operator).toBe(null);
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            this.unset();
          }

        }
      });
      const doc = {
        bar: false
      };
      (0, _expect.default)(schema.clean(doc)).toEqual({});
    });
    it('$set self and no other key', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.isSet).toBe(true);
            (0, _expect.default)(this.value).toBe(false);
            (0, _expect.default)(this.operator).toBe('$set');
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
          }

        }
      });
      const doc = {
        $set: {
          bar: false
        }
      };
      schema.clean(doc);
      (0, _expect.default)(doc).toEqual({
        $set: {
          bar: false
        }
      });
    });
    it('$set self and another key and change self', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.isSet).toBe(true);
            (0, _expect.default)(this.value).toBe(false);
            (0, _expect.default)(this.operator).toBe('$set');
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: true,
              operator: '$set',
              value: 'clown'
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: true,
              operator: '$set',
              value: 'clown'
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            return true;
          }

        }
      });
      const doc = {
        $set: {
          foo: 'clown',
          bar: false
        }
      };
      (0, _expect.default)(schema.clean(doc)).toEqual({
        $set: {
          foo: 'clown',
          bar: true
        }
      });
    });
    it('adds $set when missing', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: {
          type: String,
          optional: true
        },
        bar: {
          type: Boolean,
          optional: true,

          autoValue() {
            (0, _expect.default)(this.isSet).toBe(false);
            (0, _expect.default)(this.value).toBe(undefined);
            (0, _expect.default)(this.operator).toBe('$set');
            const foo = this.field('foo');
            (0, _expect.default)(foo).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooSibling = this.siblingField('foo');
            (0, _expect.default)(fooSibling).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            const fooParent = this.parentField();
            (0, _expect.default)(fooParent).toEqual({
              isSet: false,
              operator: null,
              value: undefined
            });
            return {
              $set: true
            };
          }

        }
      });
      (0, _expect.default)(schema.clean({}, {
        isModifier: true
      })).toEqual({
        $set: {
          bar: true
        }
      });
    });
  });
  it('content autoValues', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      content: {
        type: String,
        optional: true
      },
      updatesHistory: {
        type: Array,
        optional: true,

        autoValue() {
          const content = this.field('content');

          if (content.isSet) {
            if (!this.operator) {
              return [{
                date: new Date('2017-01-01T00:00:00.000Z'),
                content: content.value
              }];
            }

            return {
              $push: {
                date: new Date('2017-01-01T00:00:00.000Z'),
                content: content.value
              }
            };
          }
        }

      },
      'updatesHistory.$': {
        type: Object
      },
      'updatesHistory.$.content': {
        type: String,
        optional: true
      }
    }); // Normal object

    let result = schema.clean({
      content: 'foo'
    });
    (0, _expect.default)(result).toEqual({
      content: 'foo',
      updatesHistory: [{
        date: new Date('2017-01-01T00:00:00.000Z'),
        content: 'foo'
      }]
    }); // $set

    result = schema.clean({
      $set: {
        content: 'foo'
      }
    });
    (0, _expect.default)(result).toEqual({
      $set: {
        content: 'foo'
      },
      $push: {
        updatesHistory: {
          date: new Date('2017-01-01T00:00:00.000Z'),
          content: 'foo'
        }
      }
    });
  });
  it('array of objects autoValues', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      avArrayOfObjects: {
        type: Array,
        optional: true
      },
      'avArrayOfObjects.$': {
        type: Object
      },
      'avArrayOfObjects.$.a': {
        type: String
      },
      'avArrayOfObjects.$.foo': {
        type: String,

        autoValue() {
          return 'bar';
        }

      }
    });
    let result = schema.clean({
      $push: {
        avArrayOfObjects: {
          a: 'b'
        }
      }
    });
    (0, _expect.default)(result).toEqual({
      $push: {
        avArrayOfObjects: {
          a: 'b',
          foo: 'bar'
        }
      }
    });
    result = schema.clean({
      $set: {
        avArrayOfObjects: [{
          a: 'b'
        }, {
          a: 'c'
        }]
      }
    });
    (0, _expect.default)(result).toEqual({
      $set: {
        avArrayOfObjects: [{
          a: 'b',
          foo: 'bar'
        }, {
          a: 'c',
          foo: 'bar'
        }]
      }
    });
  });
  it('$each in autoValue pseudo modifier', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      psuedoEach: {
        type: Array,
        optional: true,

        autoValue() {
          if (this.isSet && this.operator === '$set') {
            return {
              $push: {
                $each: this.value
              }
            };
          }
        }

      },
      'psuedoEach.$': {
        type: String
      }
    });
    const result = schema.clean({
      $set: {
        psuedoEach: ['foo', 'bar']
      }
    });
    (0, _expect.default)(result).toEqual({
      $push: {
        psuedoEach: {
          $each: ['foo', 'bar']
        }
      }
    });
  });
  it('simple autoValues', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      name: {
        type: String
      },
      someDefault: {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.isSet) return 5;
        }

      },
      updateCount: {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.operator) return 0;
          return {
            $inc: 1
          };
        }

      },
      firstWord: {
        type: String,
        optional: true,

        autoValue() {
          const content = this.field('content');
          if (content.isSet) return content.value.split(' ')[0];
          this.unset();
        }

      }
    });
    let result = schema.clean({
      name: 'Test',
      firstWord: 'Illegal to manually set value'
    });
    (0, _expect.default)(result).toEqual({
      name: 'Test',
      someDefault: 5,
      updateCount: 0
    });
    result = schema.clean({
      name: 'Test',
      someDefault: 20
    });
    (0, _expect.default)(result).toEqual({
      name: 'Test',
      someDefault: 20,
      updateCount: 0
    });
    result = schema.clean({
      $set: {
        name: 'Test',
        someDefault: 20
      }
    });
    (0, _expect.default)(result).toEqual({
      $set: {
        name: 'Test',
        someDefault: 20
      },
      $inc: {
        updateCount: 1
      }
    });
  });
  it('objects in arrays', function () {
    const subSchema = new _SimpleSchema.SimpleSchema({
      value: {
        type: String,

        autoValue() {
          (0, _expect.default)(this.isSet).toBe(true);
          (0, _expect.default)(this.operator).toEqual('$set');
          (0, _expect.default)(this.value).toEqual('should be overridden by autovalue');
          return 'autovalue';
        }

      }
    });
    const schema = new _SimpleSchema.SimpleSchema({
      children: {
        type: Array
      },
      'children.$': {
        type: subSchema
      }
    });
    const result = schema.clean({
      $set: {
        'children.$.value': 'should be overridden by autovalue'
      }
    }, {
      isModifier: true
    });
    (0, _expect.default)(result.$set['children.$.value']).toBe('autovalue');
  });
  it('operator correct for $pull', function () {
    let called = false;
    const schema = new _SimpleSchema.SimpleSchema({
      foo: {
        type: Array,

        autoValue() {
          called = true;
          (0, _expect.default)(this.operator).toEqual('$pull');
        }

      },
      'foo.$': {
        type: String
      }
    });
    schema.clean({
      $pull: {
        foo: 'bar'
      }
    });
    (0, _expect.default)(called).toBe(true);
  });
  it('issue 340', function () {
    let called = 0;
    const schema = new _SimpleSchema.SimpleSchema({
      field1: {
        type: _SimpleSchema.SimpleSchema.Integer
      },
      field2: {
        type: String,

        autoValue() {
          called++;
          (0, _expect.default)(this.field('field1').value).toBe(1);
          (0, _expect.default)(this.siblingField('field1').value).toBe(1);
          return 'foo';
        }

      }
    });
    schema.clean({
      field1: 1
    });
    schema.clean({
      $set: {
        field1: 1
      }
    });
    (0, _expect.default)(called).toBe(2);
  });
  it('clean options should be merged when extending', function () {
    const schema1 = new _SimpleSchema.SimpleSchema({
      a: String
    }, {
      clean: {
        filter: false,
        autoConvert: false
      }
    });
    const schema2 = new _SimpleSchema.SimpleSchema({});
    schema2.extend(schema1);
    (0, _expect.default)(schema2.clean({
      a: 1
    })).toEqual({
      a: 1
    });
  });
  it('array items', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      tags: {
        type: Array,
        optional: true
      },
      'tags.$': {
        type: String,

        autoValue() {
          if (this.isSet) return this.value.toLowerCase();
        }

      }
    });
    const obj = {
      tags: []
    };
    (0, _expect.default)(schema.clean(obj)).toEqual({
      tags: []
    });
    const obj2 = {
      tags: ['FOO', 'BAR']
    };
    (0, _expect.default)(schema.clean(obj2)).toEqual({
      tags: ['foo', 'bar']
    });
  });
  it('updates existing objects when deeply nested (plain)', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      nested: Array,
      'nested.$': Object,
      'nested.$.doubleNested': Object,
      'nested.$.doubleNested.integer': {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.value) {
            return 5;
          }
        }

      }
    });
    const cleanedObject = schema.clean({
      nested: [{
        doubleNested: {}
      }, {
        doubleNested: {
          integer: '8'
        }
      }]
    });
    (0, _expect.default)(cleanedObject).toEqual({
      nested: [{
        doubleNested: {
          integer: 5
        }
      }, {
        doubleNested: {
          integer: 8
        }
      }]
    });
  });
  it('updates existing objects when deeply nested (modifier)', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      nested: Array,
      'nested.$': Object,
      'nested.$.doubleNested': Object,
      'nested.$.doubleNested.integer': {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.value) {
            return 5;
          }
        }

      }
    });
    const cleanedObject = schema.clean({
      $push: {
        nested: {
          doubleNested: {}
        }
      }
    });
    (0, _expect.default)(cleanedObject).toEqual({
      $push: {
        nested: {
          doubleNested: {
            integer: 5
          }
        }
      }
    });
  });
  it('updates deeply nested with empty $set', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      nested: Array,
      'nested.$': Object,
      'nested.$.doubleNested': {
        type: Object,

        autoValue() {
          if (!this.value) {
            return {};
          }
        }

      },
      'nested.$.doubleNested.integer': {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.value) {
            return 5;
          }
        }

      }
    });
    const cleanedObject = schema.clean({
      $set: {
        nested: [{}]
      }
    });
    (0, _expect.default)(cleanedObject).toEqual({
      $set: {
        nested: [{
          doubleNested: {
            integer: 5
          }
        }]
      }
    });
  });
  it('updates deeply nested with $set having dotted array key', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      nested: Array,
      'nested.$': Object,
      'nested.$.doubleNested': Object,
      'nested.$.doubleNested.integer': {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.value) {
            return 5;
          }
        }

      }
    });
    const cleanedObject = schema.clean({
      $set: {
        'nested.0.doubleNested': {}
      }
    });
    (0, _expect.default)(cleanedObject).toEqual({
      $set: {
        'nested.0.doubleNested': {
          integer: 5
        }
      }
    });
  });
  it('should add auto values to sub schemas for plain objects', function () {
    const doubleNestedSchema = new _SimpleSchema.SimpleSchema({
      integer: {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.value) {
            return 5;
          }
        }

      }
    });
    const nestedSchema = new _SimpleSchema.SimpleSchema({
      doubleNested: doubleNestedSchema
    });
    const schema = new _SimpleSchema.SimpleSchema({
      nested: Array,
      'nested.$': nestedSchema
    });
    const cleanedObject = schema.clean({
      nested: [{
        doubleNested: {}
      }, {
        doubleNested: {
          integer: '8'
        }
      }]
    });
    (0, _expect.default)(cleanedObject).toEqual({
      nested: [{
        doubleNested: {
          integer: 5
        }
      }, {
        doubleNested: {
          integer: 8
        }
      }]
    });
  });
  it('should add auto values to sub schemas for modifiers objects', function () {
    const doubleNestedSchema = new _SimpleSchema.SimpleSchema({
      integer: {
        type: _SimpleSchema.SimpleSchema.Integer,

        autoValue() {
          if (!this.value) {
            return 5;
          }
        }

      }
    });
    const nestedSchema = new _SimpleSchema.SimpleSchema({
      doubleNested: doubleNestedSchema
    });
    const schema = new _SimpleSchema.SimpleSchema({
      nested: Array,
      'nested.$': nestedSchema
    });
    const cleanedObject = schema.clean({
      $push: {
        nested: {
          doubleNested: {}
        }
      }
    });
    (0, _expect.default)(cleanedObject).toEqual({
      $push: {
        nested: {
          doubleNested: {
            integer: 5
          }
        }
      }
    });
  });
  it('after cleaning with one extended, autoValues do not bleed over', function () {
    const schema1 = new _SimpleSchema.SimpleSchema({
      n: Number,
      obj: {
        type: Object,
        defaultValue: {}
      }
    });
    const schema2 = schema1.clone().extend({
      'obj.b': {
        type: _SimpleSchema.SimpleSchema.Integer,
        defaultValue: 1
      }
    }); // This is a bug where after you've run autoValues with schema2, which
    // is cloned from schema1, the schema2 autoValues are not set while
    // cleaning with schema1. So we need these duplicate expects here to
    // verify it is fixed. The issue happened when a `defaultValue` was a
    // {} because additional default values within that object would actually
    // be mutated onto the original object. We now clone autoValues in
    // AutoValueRunner to fix this.

    (0, _expect.default)(schema1.clean({})).toEqual({
      obj: {}
    });
    (0, _expect.default)(schema2.clean({})).toEqual({
      obj: {
        b: 1
      }
    });
    (0, _expect.default)(schema1.clean({})).toEqual({
      obj: {}
    });
    (0, _expect.default)(schema2.clean({})).toEqual({
      obj: {
        b: 1
      }
    });
  });
});