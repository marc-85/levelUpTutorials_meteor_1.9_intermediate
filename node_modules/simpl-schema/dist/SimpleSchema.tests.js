"use strict";

var _SimpleSchema = require("./SimpleSchema");

var _expect = _interopRequireDefault(require("expect"));

var _testSchema = _interopRequireDefault(require("./testHelpers/testSchema"));

var _expectValid = _interopRequireDefault(require("./testHelpers/expectValid"));

var _expectErrorOfTypeLength = _interopRequireDefault(require("./testHelpers/expectErrorOfTypeLength"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable func-names, prefer-arrow-callback */
class CustomObject {
  constructor(obj) {
    Object.assign(this, obj);
  }

  bar() {
    return 20;
  }

}

describe('SimpleSchema', function () {
  it('throws error if first argument is an array', function () {
    (0, _expect.default)(function () {
      return new _SimpleSchema.SimpleSchema([]);
    }).toThrow('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');
  });
  it('throws error if a key is missing type', function () {
    (0, _expect.default)(function () {
      return new _SimpleSchema.SimpleSchema({
        foo: {}
      });
    }).toThrow('Invalid definition for foo field: "type" option is required');
  });
  it('throws an explicit error if you define fields that override object methods', function () {
    (0, _expect.default)(function () {
      return new _SimpleSchema.SimpleSchema({
        valueOf: {
          type: String
        }
      });
    }).toThrow('valueOf key is actually the name of a method on Object');
  });
  it('throws a error if array item definition is missing', function () {
    (0, _expect.default)(function () {
      return new _SimpleSchema.SimpleSchema({
        someArray: Array
      });
    }).toThrow('"someArray" is Array type but the schema does not include a "someArray.$" definition for the array items');
  });
  describe('nesting', function () {
    it('throws an error if a nested schema defines a field that its parent also defines', function () {
      (0, _expect.default)(function () {
        return new _SimpleSchema.SimpleSchema({
          foo: new _SimpleSchema.SimpleSchema({
            bar: String
          }),
          'foo.bar': String
        });
      }).toThrow();
    });
    it('expects a field with SimpleSchema type to be an object', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: new _SimpleSchema.SimpleSchema({
          bar: String
        })
      });
      const context = schema.newContext();
      context.validate({
        foo: 'string'
      });
      (0, _expect.default)(context.validationErrors()).toEqual([{
        dataType: 'Object',
        name: 'foo',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE,
        value: 'string'
      }]);
    });
    it('includes type validation errors from nested schemas', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: new _SimpleSchema.SimpleSchema({
          bar: String
        })
      });
      const context = schema.newContext();
      context.validate({
        foo: {
          bar: 12345
        }
      });
      (0, _expect.default)(context.validationErrors()).toEqual([{
        dataType: 'String',
        name: 'foo.bar',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE,
        value: 12345
      }]);
    });
    it('includes allowed value validation errors from nested schemas', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: new _SimpleSchema.SimpleSchema({
          bar: {
            type: String,
            allowedValues: ['hot']
          }
        })
      });
      const context = schema.newContext();
      context.validate({
        foo: {
          bar: 'cold'
        }
      });
      (0, _expect.default)(context.validationErrors()).toEqual([{
        name: 'foo.bar',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.VALUE_NOT_ALLOWED,
        value: 'cold'
      }]);
    });
    it('includes validation errors from nested schemas when validating modifiers', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        foo: new _SimpleSchema.SimpleSchema({
          bar: String
        })
      });
      const context = schema.newContext();
      context.validate({
        $set: {
          'foo.bar': 12345
        }
      }, {
        modifier: true
      });
      (0, _expect.default)(context.validationErrors()).toEqual([{
        dataType: 'String',
        name: 'foo.bar',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE,
        value: 12345
      }]);
    });
    it('validates nested requiredness', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        a: {
          type: new _SimpleSchema.SimpleSchema({
            b: {
              type: new _SimpleSchema.SimpleSchema({
                c: {
                  type: String
                }
              })
            }
          })
        }
      });
      let context = schema.newContext();
      context.validate({
        a: {}
      });
      (0, _expect.default)(context.validationErrors()).toEqual([{
        name: 'a.b',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED,
        value: undefined
      }, {
        name: 'a.b.c',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED,
        value: undefined
      }]);
      context = schema.newContext();
      context.validate({
        a: {
          b: {}
        }
      });
      (0, _expect.default)(context.validationErrors()).toEqual([{
        name: 'a.b.c',
        type: _SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED,
        value: undefined
      }]);
    });
    it('issue #307 - throws an error if incorrect import results in empty object', function () {
      (0, _expect.default)(function () {
        // Assume that default import of a file with no default export returns an empty object
        const Place = {}; // eslint-disable-next-line no-new

        new _SimpleSchema.SimpleSchema({
          places: {
            type: Array,
            label: 'Places',
            optional: true
          },
          'places.$': {
            type: Place
          }
        });
      }).toThrow('Invalid definition for places.$ field: "type" may not be an object. Change it to Object');
    });
  });
  it('Safely sets defaultValues on subschemas nested in arrays', function () {
    const nestedSchema = new _SimpleSchema.SimpleSchema({
      nested: {
        type: Array
      },
      'nested.$': {
        type: new _SimpleSchema.SimpleSchema({
          somethingOptional: {
            type: String,
            optional: true
          },
          somethingAutovalued: {
            type: String,
            optional: false,
            defaultValue: 'x'
          }
        })
      }
    });
    const context = nestedSchema.newContext();
    const cleaned = context.clean({
      $set: {
        nested: [{
          somethingOptional: 'q'
        }, {
          somethingOptional: 'z'
        }]
      }
    }, {
      modifier: true
    });
    (0, _expect.default)(cleaned).toEqual({
      $set: {
        nested: [{
          somethingAutovalued: 'x',
          somethingOptional: 'q'
        }, {
          somethingAutovalued: 'x',
          somethingOptional: 'z'
        }]
      }
    });
  });
  it('Issue #123', function () {
    // With $set
    const userSchema = new _SimpleSchema.SimpleSchema({
      profile: {
        type: Object
      },
      'profile.name': {
        type: String
      }
    });
    const context = userSchema.namedContext();
    (0, _expect.default)(context.validate({
      $set: {
        profile: {}
      }
    }, {
      modifier: true
    })).toBe(false); // With $push

    const userSchema2 = new _SimpleSchema.SimpleSchema({
      profile: {
        type: Array
      },
      'profile.$': {
        type: Object
      },
      'profile.$.name': {
        type: String
      }
    });
    const context2 = userSchema2.namedContext();
    (0, _expect.default)(context2.validate({
      $push: {
        profile: {}
      }
    }, {
      modifier: true
    })).toBe(false);
  });
  it('validate object with prototype', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      foo: {
        type: _SimpleSchema.SimpleSchema.Integer
      }
    });
    const testObj = new CustomObject({
      foo: 1
    });
    const context = schema.namedContext();
    (0, _expect.default)(context.validate(testObj)).toBe(true);
    (0, _expect.default)(testObj instanceof CustomObject).toBe(true);
    testObj.foo = 'not a number';
    (0, _expect.default)(context.validate(testObj)).toBe(false);
  });
  it('validate object with prototype within normal object', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      customObject: Object,
      'customObject.foo': _SimpleSchema.SimpleSchema.Integer
    });
    const customObject = new CustomObject({
      foo: 1
    });
    const testObj = {
      customObject
    };
    const context = schema.namedContext();
    (0, _expect.default)(context.validate(testObj)).toBe(true);
    (0, _expect.default)(testObj.customObject instanceof CustomObject).toBe(true);
    testObj.customObject.foo = 'not a number';
    (0, _expect.default)(context.validate(testObj)).toBe(false);
  });
  it('allowsKey', function () {
    function run(key, allowed) {
      (0, _expect.default)(_testSchema.default.allowsKey(key)).toBe(allowed);
    }

    run('minMaxString', true);
    run('minMaxString.$', false);
    run('minMaxString.$.foo', false);
    run('minMaxString.$foo', false);
    run('minMaxString.foo', false);
    run('sub', true);
    run('sub.number', true);
    run('sub.number.$', false);
    run('sub.number.$.foo', false);
    run('sub.number.$foo', false);
    run('sub.number.foo', false);
    run('minMaxStringArray', true);
    run('minMaxStringArray.$', true);
    run('minMaxStringArray.$.foo', false);
    run('minMaxStringArray.foo', false);
    run('customObject', true);
    run('customObject.$', false);
    run('customObject.foo', true);
    run('customObject.foo.$', true);
    run('customObject.foo.$foo', true);
    run('customObject.foo.$.$foo', true);
    run('blackBoxObject', true);
    run('blackBoxObject.$', false);
    run('blackBoxObject.foo', true);
    run('blackBoxObject.foo.$', true);
    run('blackBoxObject.foo.$foo', true);
    run('blackBoxObject.foo.$.$foo', true);
    run('blackBoxObject.foo.bar.$.baz', true);
  });
  it('allowsKey in subschema', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      foo: new _SimpleSchema.SimpleSchema({
        bar: Object,
        'bar.baz': String
      })
    });
    (0, _expect.default)(schema.allowsKey('foo.bar')).toBe(true);
    (0, _expect.default)(schema.allowsKey('foo.bar.baz')).toBe(true);
    (0, _expect.default)(schema.allowsKey('foo.bar.bum')).toBe(false);
    (0, _expect.default)(schema.allowsKey('foo.bar.baz.bum')).toBe(false);
  });
  it('validating an object with a "length" property should not error', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      length: {
        type: Number,
        optional: true
      }
    });
    (0, _expect.default)(() => {
      schema.validate({
        length: 10
      });
      schema.validate({
        $set: {
          length: 10
        }
      }, {
        modifier: true
      });
    }).toNotThrow();
  });
  it('extend with no type', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      name: {
        type: String,
        min: 5
      }
    });
    schema.extend({
      name: {
        max: 15
      }
    });
    (0, _expect.default)(schema.get('name', 'max')).toBe(15);
  });
  it('this.key in label function context', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      items: Array,
      'items.$': {
        type: String,

        label() {
          const {
            key
          } = this;
          if (!key) return 'Item';
          return `Item ${key.slice(key.lastIndexOf('.') + 1)}`;
        }

      }
    });
    (0, _expect.default)(schema.label('items.0')).toBe('Item 0');
    (0, _expect.default)(schema.label('items.1')).toBe('Item 1');
  });
  it('keyIsInBlackBox in subschema', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      foo: new _SimpleSchema.SimpleSchema({
        bar: {
          type: Object,
          blackbox: true
        }
      })
    });
    (0, _expect.default)(schema.keyIsInBlackBox('foo.bar')).toBe(false);
    (0, _expect.default)(schema.keyIsInBlackBox('foo.bar.baz')).toBe(true);
    (0, _expect.default)(schema.keyIsInBlackBox('foo.bar.baz.$.bum')).toBe(true);
  });
  describe('blackboxKeys from subschema', function () {
    it('are correct', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        apple: {
          type: Object,
          blackbox: true
        },
        pear: new _SimpleSchema.SimpleSchema({
          info: {
            type: Object,
            blackbox: true
          }
        })
      });
      (0, _expect.default)(schema.blackboxKeys()).toEqual(['apple', 'pear.info']);
    });
    it('are updated after extending', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        apple: {
          type: Object,
          blackbox: true
        },
        pear: new _SimpleSchema.SimpleSchema({
          info: {
            type: Object,
            blackbox: true
          }
        })
      });
      schema.extend({
        pear: String
      });
      (0, _expect.default)(schema.blackboxKeys()).toEqual(['apple']);
    });
  });
  describe('extend', function () {
    it('works for plain object', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        firstName: {
          type: String,
          label: 'First name',
          optional: false
        },
        lastName: {
          type: String,
          label: 'Last name',
          optional: false
        }
      });
      schema.extend({
        firstName: {
          optional: true
        }
      });
      (0, _expect.default)(schema.schema()).toEqual({
        firstName: {
          type: _SimpleSchema.SimpleSchema.oneOf(String),
          label: 'First name',
          optional: true
        },
        lastName: {
          type: _SimpleSchema.SimpleSchema.oneOf(String),
          label: 'Last name',
          optional: false
        }
      });
    });
    it('works for another SimpleSchema instance and copies validators', function () {
      const schema1 = new _SimpleSchema.SimpleSchema({
        firstName: {
          type: String,
          label: 'First name',
          optional: false
        },
        lastName: {
          type: String,
          label: 'Last name',
          optional: false
        }
      });
      const schema2 = new _SimpleSchema.SimpleSchema({
        age: {
          type: Number,
          label: 'Age'
        }
      });
      schema2.addValidator(() => {});
      schema2.addDocValidator(() => {});
      (0, _expect.default)(schema1.schema()).toEqual({
        firstName: {
          type: _SimpleSchema.SimpleSchema.oneOf(String),
          label: 'First name',
          optional: false
        },
        lastName: {
          type: _SimpleSchema.SimpleSchema.oneOf(String),
          label: 'Last name',
          optional: false
        }
      });
      (0, _expect.default)(schema1._validators.length).toBe(0);
      (0, _expect.default)(schema1._docValidators.length).toBe(0);
      schema1.extend(schema2);
      (0, _expect.default)(schema1.schema()).toEqual({
        firstName: {
          type: _SimpleSchema.SimpleSchema.oneOf(String),
          label: 'First name',
          optional: false
        },
        lastName: {
          type: _SimpleSchema.SimpleSchema.oneOf(String),
          label: 'Last name',
          optional: false
        },
        age: {
          type: _SimpleSchema.SimpleSchema.oneOf(Number),
          label: 'Age',
          optional: false
        }
      });
      (0, _expect.default)(schema1._validators.length).toBe(1);
      (0, _expect.default)(schema1._docValidators.length).toBe(1);
    });
    it('keeps both min and max', function () {
      const schema = new _SimpleSchema.SimpleSchema({
        name: {
          type: String,
          min: 5
        }
      });
      schema.extend({
        name: {
          type: String,
          max: 15
        }
      });
      (0, _expect.default)(schema._schema.name.type.definitions[0].min).toBe(5);
      (0, _expect.default)(schema._schema.name.type.definitions[0].max).toBe(15);
    });
    it('does not mutate a schema that is passed to extend', function () {
      const itemSchema = new _SimpleSchema.SimpleSchema({
        _id: String
      });
      const mainSchema = new _SimpleSchema.SimpleSchema({
        items: Array,
        'items.$': itemSchema
      });
      const item2Schema = new _SimpleSchema.SimpleSchema({
        blah: String
      });
      const main2Schema = new _SimpleSchema.SimpleSchema({
        items: Array,
        'items.$': item2Schema
      });
      new _SimpleSchema.SimpleSchema({}).extend(mainSchema).extend(main2Schema);
      (0, _expect.default)(mainSchema._schema['items.$'].type.definitions[0].type._schemaKeys).toEqual(['_id']);
    });
  });
  it('empty required array is valid', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      names: {
        type: Array
      },
      'names.$': {
        type: String
      }
    });
    (0, _expectValid.default)(schema, {
      names: []
    });
  });
  it('null in array is not valid', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      names: {
        type: Array
      },
      'names.$': {
        type: String
      }
    });
    (0, _expectErrorOfTypeLength.default)(_SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE, schema, {
      names: [null]
    });
  });
  it('null is valid for optional', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      test: {
        type: String,
        optional: true
      }
    });
    (0, _expectValid.default)(schema, {
      test: null
    });
  });
  it('issue 360', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      emails: {
        type: Array
      },
      'emails.$': {
        type: Object
      },
      'emails.$.address': {
        type: String,
        regEx: _SimpleSchema.SimpleSchema.RegEx.Email
      },
      'emails.$.verified': {
        type: Boolean
      }
    });
    (0, _expectErrorOfTypeLength.default)(_SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE, schema, {
      emails: [{
        address: 12321,
        verified: 'asdasd'
      }]
    }, {
      keys: ['emails']
    }).toBe(2);
    (0, _expectErrorOfTypeLength.default)(_SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE, schema, {
      emails: [{
        address: 12321,
        verified: 'asdasd'
      }]
    }, {
      keys: ['emails.0']
    }).toBe(2);
  });
  it('ignore option', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      foo: {
        type: String,
        optional: true
      }
    });
    (0, _expectValid.default)(schema, {
      foo: 'bar'
    });
    (0, _expectValid.default)(schema, {
      foo: 'bar'
    }, {
      ignore: [_SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA]
    });
    (0, _expectValid.default)(schema, {
      foo: 'bar'
    }, {
      keys: ['foo'],
      ignore: [_SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA]
    });
    (0, _expectErrorOfTypeLength.default)(_SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA, schema, {
      bar: 'foo'
    });
    (0, _expectValid.default)(schema, {
      bar: 'foo'
    }, {
      ignore: [_SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA]
    });
    (0, _expectValid.default)(schema, {
      bar: 'foo'
    }, {
      keys: ['bar'],
      ignore: [_SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA]
    });
  });
  it('ClientError', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      int: _SimpleSchema.SimpleSchema.Integer,
      string: String
    });

    function verify(error) {
      (0, _expect.default)(error.name).toBe('ClientError');
      (0, _expect.default)(error.errorType).toBe('ClientError');
      (0, _expect.default)(error.error).toBe('validation-error');
      (0, _expect.default)(error.details.length).toBe(2);
      (0, _expect.default)(error.details[0].name).toBe('int');
      (0, _expect.default)(error.details[0].type).toBe(_SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE);
      (0, _expect.default)(error.details[0].message).toBe('Int must be of type Integer');
      (0, _expect.default)(error.details[1].name).toBe('string');
      (0, _expect.default)(error.details[1].type).toBe(_SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED);
      (0, _expect.default)(error.details[1].message).toBe('String is required'); // In order for the message at the top of the stack trace to be useful,
      // we set it to the first validation error message.

      (0, _expect.default)(error.reason, 'Int must be of type Integer');
      (0, _expect.default)(error.message, 'Int must be of type Integer [validation-error]');
    }

    try {
      schema.validate({
        int: '5'
      });
    } catch (error) {
      verify(error);
    }

    try {
      _SimpleSchema.SimpleSchema.validate({
        int: '5'
      }, schema);
    } catch (error) {
      verify(error);
    }

    try {
      _SimpleSchema.SimpleSchema.validate({
        int: '5'
      }, {
        int: _SimpleSchema.SimpleSchema.Integer,
        string: String
      });
    } catch (error) {
      verify(error);
    }

    try {
      schema.validator()({
        int: '5'
      });
    } catch (error) {
      verify(error);
    }

    (0, _expect.default)(function () {
      schema.validator({
        clean: true
      })({
        int: '5',
        string: 'test'
      });
    }).toNotThrow();
  });
  it('getFormValidator', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      int: _SimpleSchema.SimpleSchema.Integer,
      string: String
    });
    return Promise.all([schema.getFormValidator()({
      int: '5'
    }).then(errors => {
      (0, _expect.default)(errors).toEqual([{
        dataType: 'Integer',
        message: 'Int must be of type Integer',
        name: 'int',
        type: 'expectedType',
        value: '5'
      }, {
        message: 'String is required',
        name: 'string',
        type: 'required',
        value: undefined
      }]);
    }), schema.getFormValidator({
      clean: true
    })({
      int: '5',
      string: 'test'
    }).then(errors => {
      (0, _expect.default)(errors).toEqual([]);
    })]);
  });
  it('validate takes an array', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      int: _SimpleSchema.SimpleSchema.Integer,
      string: String
    });

    function verify(error) {
      (0, _expect.default)(error.name).toBe('ClientError');
      (0, _expect.default)(error.errorType).toBe('ClientError');
      (0, _expect.default)(error.error).toBe('validation-error');
      (0, _expect.default)(error.details.length).toBe(2);
      (0, _expect.default)(error.details[0].name).toBe('int');
      (0, _expect.default)(error.details[0].type).toBe(_SimpleSchema.SimpleSchema.ErrorTypes.EXPECTED_TYPE);
      (0, _expect.default)(error.details[1].name).toBe('string');
      (0, _expect.default)(error.details[1].type).toBe(_SimpleSchema.SimpleSchema.ErrorTypes.REQUIRED); // In order for the message at the top of the stack trace to be useful,
      // we set it to the first validation error message.

      (0, _expect.default)(error.reason, 'Int must be of type Integer');
      (0, _expect.default)(error.message, 'Int must be of type Integer [validation-error]');
    }

    try {
      schema.validate([{
        int: 5,
        string: 'test'
      }, {
        int: '5'
      }]);
    } catch (error) {
      verify(error);
    }

    try {
      _SimpleSchema.SimpleSchema.validate([{
        int: 5,
        string: 'test'
      }, {
        int: '5'
      }], schema);
    } catch (error) {
      verify(error);
    }

    try {
      _SimpleSchema.SimpleSchema.validate([{
        int: 5,
        string: 'test'
      }, {
        int: '5'
      }], {
        int: _SimpleSchema.SimpleSchema.Integer,
        string: String
      });
    } catch (error) {
      verify(error);
    }

    try {
      schema.validator()([{
        int: 5,
        string: 'test'
      }, {
        int: '5'
      }]);
    } catch (error) {
      verify(error);
    }
  });
  it('validationErrorTransform', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      string: String
    });

    _SimpleSchema.SimpleSchema.defineValidationErrorTransform(error => {
      error.message = 'validationErrorTransform';
      return error;
    });

    try {
      schema.validate({});
    } catch (e) {
      (0, _expect.default)(e.message).toBe('validationErrorTransform');
    } // Don't mess up other tests


    _SimpleSchema.SimpleSchema.validationErrorTransform = null;
  });
  it('SimpleSchema.addDocValidator', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      string: String
    });
    const errorArray = [{
      name: 'firstName',
      type: 'TOO_SILLY',
      value: 'Reepicheep'
    }];
    const validatedObject = {
      string: 'String'
    };

    _SimpleSchema.SimpleSchema.addDocValidator(obj => {
      (0, _expect.default)(obj).toEqual(validatedObject);
      return errorArray;
    });

    const context = schema.newContext();
    context.validate(validatedObject);
    (0, _expect.default)(context.validationErrors()).toEqual(errorArray); // Don't mess up other tests

    _SimpleSchema.SimpleSchema._docValidators = [];
  });
  it('addDocValidator', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      string: String
    });
    const errorArray = [{
      name: 'firstName',
      type: 'TOO_SILLY',
      value: 'Reepicheep'
    }];
    const validatedObject = {
      string: 'String'
    };
    schema.addDocValidator(obj => {
      (0, _expect.default)(obj).toEqual(validatedObject);
      return errorArray;
    });
    const context = schema.newContext();
    context.validate(validatedObject);
    (0, _expect.default)(context.validationErrors()).toEqual(errorArray);
  });
  it('sets _objectKeys', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      a: Object,
      'a.b': Object,
      'a.b.c': Array,
      'a.b.c.$': Object,
      'a.b.c.$.d': Object,
      'a.b.c.$.d.e': String
    });
    (0, _expect.default)(schema._objectKeys).toEqual({
      'a.': ['b'],
      'a.b.': ['c'],
      'a.b.c.$.': ['d'],
      'a.b.c.$.d.': ['e']
    });
  });
  it('gets subschema objectKeys', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      a: {
        type: new _SimpleSchema.SimpleSchema({
          b: {
            type: new _SimpleSchema.SimpleSchema({
              c: {
                type: String
              }
            })
          }
        })
      }
    });
    (0, _expect.default)(schema.objectKeys('a')).toEqual(['b']);
    (0, _expect.default)(schema.objectKeys('a.b')).toEqual(['c']);
  });
  it('gets schema property by key', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      a: {
        type: new _SimpleSchema.SimpleSchema({
          b: {
            type: new _SimpleSchema.SimpleSchema({
              c: {
                type: String,
                defaultValue: 'abc'
              }
            }),
            defaultValue: 'ab'
          },
          d: _SimpleSchema.SimpleSchema.oneOf({
            type: Array,
            minCount: 0,
            maxCount: 3
          }, {
            type: _SimpleSchema.SimpleSchema.Integer,
            min: 0
          }),
          'd.$': String
        })
      }
    });
    (0, _expect.default)(schema.get('a', 'defaultValue')).toBe(undefined);
    (0, _expect.default)(schema.get('a.b', 'defaultValue')).toBe('ab');
    (0, _expect.default)(schema.get('a.d', 'maxCount')).toBe(3);
  });
  it('exposes defaultValue for a key', function () {
    const schema = new _SimpleSchema.SimpleSchema({
      a: {
        type: new _SimpleSchema.SimpleSchema({
          b: {
            type: new _SimpleSchema.SimpleSchema({
              c: {
                type: String,
                defaultValue: 'abc'
              }
            }),
            defaultValue: 'ab'
          }
        })
      }
    });
    (0, _expect.default)(schema.defaultValue('a')).toBe(undefined);
    (0, _expect.default)(schema.defaultValue('a.b')).toBe('ab');
    (0, _expect.default)(schema.defaultValue('a.b.c')).toBe('abc');
  });
  it('issue #232', function () {
    let foo;
    (0, _expect.default)(function () {
      const schema3 = new _SimpleSchema.SimpleSchema({
        foo: String
      });
      const schema2 = new _SimpleSchema.SimpleSchema({
        field2: {
          type: Array,
          optional: true
        },
        'field2.$': schema3
      });
      foo = new _SimpleSchema.SimpleSchema({
        field1: {
          type: schema2,
          defaultValue: {}
        }
      });
    }).toNotThrow();
    (0, _expect.default)(foo instanceof _SimpleSchema.SimpleSchema).toBe(true);
  });
});