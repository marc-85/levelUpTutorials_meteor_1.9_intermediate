"use strict";

var _SimpleSchema = require("./SimpleSchema");

var _expectErrorLength = _interopRequireDefault(require("./testHelpers/expectErrorLength"));

var _expectErrorOfTypeLength = _interopRequireDefault(require("./testHelpers/expectErrorOfTypeLength"));

var _expect = _interopRequireDefault(require("expect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable func-names, prefer-arrow-callback */
const schema = new _SimpleSchema.SimpleSchema({
  password: {
    type: String
  },
  confirmPassword: {
    type: String,

    custom() {
      if (this.value !== this.field('password').value) {
        return 'passwordMismatch';
      }
    }

  }
});
const requiredCustomSchema = new _SimpleSchema.SimpleSchema({
  a: {
    type: Array,

    custom() {// Just adding custom to trigger extra validation
    }

  },
  'a.$': {
    type: Object,

    custom() {// Just adding custom to trigger extra validation
    }

  },
  b: {
    type: Array,

    custom() {// Just adding custom to trigger extra validation
    }

  },
  'b.$': {
    type: Object,

    custom() {// Just adding custom to trigger extra validation
    }

  }
});
describe('SimpleSchema - Validation Against Another Key', function () {
  describe('normal', function () {
    it('valid', function () {
      (0, _expectErrorLength.default)(schema, {
        password: 'password',
        confirmPassword: 'password'
      }).toEqual(0);
    });
    it('invalid', function () {
      (0, _expectErrorOfTypeLength.default)('passwordMismatch', schema, {
        password: 'password',
        confirmPassword: 'password1'
      }).toEqual(1);
    });
  });
  describe('modifier with $setOnInsert', function () {
    it('valid', function () {
      (0, _expectErrorLength.default)(schema, {
        $setOnInsert: {
          password: 'password',
          confirmPassword: 'password'
        }
      }, {
        modifier: true,
        upsert: true
      }).toEqual(0);
    });
    it('invalid', function () {
      (0, _expectErrorOfTypeLength.default)('passwordMismatch', schema, {
        $setOnInsert: {
          password: 'password',
          confirmPassword: 'password1'
        }
      }, {
        modifier: true,
        upsert: true
      }).toEqual(1);
    });
  });
  describe('modifier with $set', function () {
    it('valid', function () {
      (0, _expectErrorLength.default)(schema, {
        $set: {
          password: 'password',
          confirmPassword: 'password'
        }
      }, {
        modifier: true
      }).toEqual(0);
    });
    it('invalid', function () {
      (0, _expectErrorOfTypeLength.default)('passwordMismatch', schema, {
        $set: {
          password: 'password',
          confirmPassword: 'password1'
        }
      }, {
        modifier: true
      }).toEqual(1);
    });
  });
});
describe('custom', function () {
  it('custom validator has this.validationContext set', function () {
    let ok = false;
    const customSchema = new _SimpleSchema.SimpleSchema({
      foo: {
        type: String,
        optional: true,

        custom() {
          if (this.validationContext instanceof _SimpleSchema.ValidationContext) ok = true;
        }

      }
    });
    customSchema.namedContext().validate({});
    (0, _expect.default)(ok).toBe(true);
  });
  it('custom validation runs even when the optional field is undefined', function () {
    const customSchema = new _SimpleSchema.SimpleSchema({
      foo: {
        type: String,
        optional: true,
        custom: () => 'custom'
      }
    });
    const context = customSchema.namedContext();
    context.validate({});
    (0, _expect.default)(context.validationErrors().length).toEqual(1);
    (0, _expect.default)(context.validationErrors()[0]).toEqual({
      name: 'foo',
      type: 'custom',
      value: undefined
    });
  });
  it('custom validation runs when string is unset', function () {
    const customSchema = new _SimpleSchema.SimpleSchema({
      foo: {
        type: String,
        optional: true,
        custom: () => 'custom'
      }
    });
    const context = customSchema.namedContext();
    context.validate({
      $unset: {
        foo: ''
      }
    }, {
      modifier: true
    });
    (0, _expect.default)(context.validationErrors().length).toEqual(1);
    (0, _expect.default)(context.validationErrors()[0]).toEqual({
      name: 'foo',
      type: 'custom',
      value: ''
    });
  });
  it('we do not get required errors for a required field that has a `custom` function when we are $setting', function () {
    const context = requiredCustomSchema.namedContext();
    (0, _expect.default)(context.validate({
      $set: {
        a: [{}]
      }
    }, {
      modifier: true
    })).toEqual(true);
    (0, _expect.default)(context.validate({
      $set: {
        'a.0': {}
      }
    }, {
      modifier: true
    })).toEqual(true);
  });
  it('we do not get required errors for a required field that has a `custom` function when we are $pushing', function () {
    const context = requiredCustomSchema.namedContext();
    (0, _expect.default)(context.validate({
      $push: {
        a: {}
      }
    }, {
      modifier: true
    })).toEqual(true);
  });
});